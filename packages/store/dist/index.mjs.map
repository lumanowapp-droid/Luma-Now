{"version":3,"sources":["../src/createStore.ts","../src/storage/storageAdapter.web.ts","../src/middleware/persistenceMiddleware.ts","../src/slices/brainDumpSlice.ts","../src/slices/tasksSlice.ts","../src/slices/capacitySlice.ts","../src/slices/focusSlice.ts","../src/slices/uiSlice.ts","../src/slices/settingsSlice.ts"],"sourcesContent":["import { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\nimport { persist } from './middleware/persistenceMiddleware'\nimport { createBrainDumpSlice } from './slices/brainDumpSlice'\nimport { createTasksSlice } from './slices/tasksSlice'\nimport { createCapacitySlice } from './slices/capacitySlice'\nimport { createFocusSlice } from './slices/focusSlice'\nimport { createUISlice } from './slices/uiSlice'\nimport { createSettingsSlice } from './slices/settingsSlice'\nimport { LumaStore } from './types'\n\n/**\n * Main Luma Store\n *\n * Combines all 6 slices into a single Zustand store with:\n * - Immer middleware for safe mutations\n * - Persistence middleware for selective state saving\n * - Platform-agnostic storage (web/mobile)\n *\n * Persisted state (survives app restart):\n * - tasks[]\n * - currentCapacity, maxTasks\n * - settings\n *\n * Ephemeral state (resets on load):\n * - text, isProcessing\n * - currentTaskId, elapsedTime, isActive\n * - currentView, modalOpen\n */\nexport const useLumaStore = create<LumaStore>()(\n  immer(\n    persist(\n      (...args) => ({\n        ...createBrainDumpSlice(...args),\n        ...createTasksSlice(...args),\n        ...createCapacitySlice(...args),\n        ...createFocusSlice(...args),\n        ...createUISlice(...args),\n        ...createSettingsSlice(...args),\n      }),\n      {\n        name: 'luma-store',\n        version: 1,\n        partialize: (state) => ({\n          // Only persist these parts of the state\n          tasks: state.tasks,\n          currentCapacity: state.currentCapacity,\n          maxTasks: state.maxTasks,\n          settings: state.settings,\n          // Everything else is ephemeral and resets on load\n        }),\n        onRehydrateStorage: (state) => {\n          console.log('Luma store rehydrated from storage')\n        },\n      }\n    )\n  )\n)\n\n// ===================================\n// SELECTORS FOR OPTIMIZED SUBSCRIPTIONS\n// ===================================\n\n/**\n * Select all tasks\n * Use: const tasks = useLumaStore(selectTasks)\n */\nexport const selectTasks = (state: LumaStore) => state.tasks\n\n/**\n * Select current view\n * Use: const view = useLumaStore(selectCurrentView)\n */\nexport const selectCurrentView = (state: LumaStore) => state.currentView\n\n/**\n * Select capacity state\n * Use: const { level, max } = useLumaStore(selectCapacity)\n */\nexport const selectCapacity = (state: LumaStore) => ({\n  level: state.currentCapacity,\n  max: state.maxTasks,\n})\n\n/**\n * Select settings\n * Use: const settings = useLumaStore(selectSettings)\n */\nexport const selectSettings = (state: LumaStore) => state.settings\n\n/**\n * Select brain dump text\n * Use: const text = useLumaStore(selectBrainDumpText)\n */\nexport const selectBrainDumpText = (state: LumaStore) => state.text\n\n/**\n * Select processing state\n * Use: const isProcessing = useLumaStore(selectIsProcessing)\n */\nexport const selectIsProcessing = (state: LumaStore) => state.isProcessing\n\n/**\n * Select focus state\n * Use: const { taskId, elapsed, active } = useLumaStore(selectFocusState)\n */\nexport const selectFocusState = (state: LumaStore) => ({\n  taskId: state.currentTaskId,\n  elapsed: state.elapsedTime,\n  active: state.isActive,\n})\n\n/**\n * Select modal state\n * Use: const modalOpen = useLumaStore(selectModalOpen)\n */\nexport const selectModalOpen = (state: LumaStore) => state.modalOpen\n","import { StorageAdapter } from './storageAdapter'\n\n/**\n * Check if we're running in a browser environment\n */\nconst isBrowser = () => {\n  return typeof window !== 'undefined' && typeof localStorage !== 'undefined'\n}\n\n/**\n * Web storage implementation using localStorage\n * Used by Next.js and other web frameworks\n */\nexport const storage: StorageAdapter = {\n  getItem: async (key: string): Promise<string | null> => {\n    try {\n      if (!isBrowser()) {\n        return null\n      }\n      return localStorage.getItem(key)\n    } catch (error) {\n      console.error('localStorage.getItem failed:', error)\n      return null\n    }\n  },\n\n  setItem: async (key: string, value: string): Promise<void> => {\n    try {\n      if (!isBrowser()) {\n        return\n      }\n      localStorage.setItem(key, value)\n    } catch (error) {\n      console.error('localStorage.setItem failed:', error)\n      // Fail silently to prevent app crashes on quota exceeded\n    }\n  },\n\n  removeItem: async (key: string): Promise<void> => {\n    try {\n      if (!isBrowser()) {\n        return\n      }\n      localStorage.removeItem(key)\n    } catch (error) {\n      console.error('localStorage.removeItem failed:', error)\n    }\n  },\n}\n","import { StateCreator, StoreApi } from 'zustand'\nimport { storage } from '../storage/storageAdapter'\n\n/**\n * Options for persistence middleware\n */\ninterface PersistOptions<T> {\n  name: string\n  version: number\n  partialize?: (state: T) => Partial<T>\n  onRehydrateStorage?: (state: T) => void\n}\n\n/**\n * Persisted state structure with versioning\n */\ninterface PersistedState<T> {\n  state: Partial<T>\n  version: number\n}\n\n/**\n * Custom persistence middleware for Zustand\n *\n * Features:\n * - Selective persistence via partialize function\n * - Version tracking for future migrations\n * - Error handling (corrupted state doesn't crash app)\n * - Automatic rehydration on initialization\n * - Platform-agnostic storage (web/mobile)\n */\nexport const persist = <T extends object>(\n  config: StateCreator<T>,\n  options: PersistOptions<T>\n): StateCreator<T> => {\n  return (set, get, api) => {\n    const { name, version, partialize, onRehydrateStorage } = options\n\n    // Load persisted state on initialization\n    const loadState = async () => {\n      try {\n        const persistedStateString = await storage.getItem(name)\n\n        if (persistedStateString) {\n          const persistedData: PersistedState<T> = JSON.parse(persistedStateString)\n\n          // Version check for migrations\n          if (persistedData.version === version) {\n            // Merge persisted state with current state\n            set(persistedData.state as Partial<T>)\n\n            if (onRehydrateStorage) {\n              onRehydrateStorage(get())\n            }\n          } else {\n            console.warn(\n              `State version mismatch for \"${name}\": expected ${version}, got ${persistedData.version}`\n            )\n            // Future: Add migration logic here\n            // For now, clear invalid state\n            await storage.removeItem(name)\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to load persisted state for \"${name}\":`, error)\n        // Don't crash the app, just continue with initial state\n      }\n    }\n\n    // Save state on every update\n    const saveState = async (state: T) => {\n      try {\n        // Select which parts of state to persist\n        const stateToPersist = partialize ? partialize(state) : state\n\n        const persistedData: PersistedState<T> = {\n          state: stateToPersist,\n          version,\n        }\n\n        const serialized = JSON.stringify(persistedData)\n        await storage.setItem(name, serialized)\n      } catch (error) {\n        console.error(`Failed to persist state for \"${name}\":`, error)\n        // Fail silently to prevent app crashes\n      }\n    }\n\n    // Subscribe to state changes and persist\n    api.subscribe((state) => {\n      saveState(state)\n    })\n\n    // Load initial persisted state\n    loadState()\n\n    // Return the original config\n    return config(set, get, api)\n  }\n}\n","import { StateCreator } from 'zustand'\nimport { LumaStore, BrainDumpSlice } from '../types'\n\nconst initialState = {\n  text: '',\n  isProcessing: false,\n}\n\n/**\n * Brain Dump Slice\n *\n * Manages the brain dump text input and processing state.\n * This is ephemeral state - resets on app load for fresh start.\n */\nexport const createBrainDumpSlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  BrainDumpSlice\n> = (set) => ({\n  ...initialState,\n\n  setText: (text) => {\n    set((state) => {\n      state.text = text\n    })\n  },\n\n  setIsProcessing: (isProcessing) => {\n    set((state) => {\n      state.isProcessing = isProcessing\n    })\n  },\n\n  compress: async () => {\n    // This is called from components with AI compression logic\n    // Store just manages the state\n    set((state) => {\n      state.isProcessing = true\n    })\n  },\n\n  reset: () => {\n    set((state) => {\n      state.text = initialState.text\n      state.isProcessing = initialState.isProcessing\n    })\n  },\n})\n","import { StateCreator } from 'zustand'\nimport { LumaStore, TasksSlice, Task } from '../types'\n\nconst initialState = {\n  tasks: [],\n}\n\n/**\n * Tasks Slice\n *\n * Core task management with rich Task type from packages/types.\n * Supports CRUD operations, reordering, and auto-generation of id/order/timestamps.\n * This state is persisted - survives app restarts.\n */\nexport const createTasksSlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  TasksSlice\n> = (set) => ({\n  ...initialState,\n\n  addTask: (task) => {\n    set((state) => {\n      const newTask: Task = {\n        ...task,\n        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        createdAt: new Date(),\n        order: state.tasks.length,\n      }\n      state.tasks.push(newTask)\n    })\n  },\n\n  addTasks: (tasks) => {\n    set((state) => {\n      const startOrder = state.tasks.length\n      const newTasks: Task[] = tasks.map((task, index) => ({\n        ...task,\n        id: `${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`,\n        createdAt: new Date(),\n        order: startOrder + index,\n      }))\n      state.tasks.push(...newTasks)\n    })\n  },\n\n  toggleTask: (id) => {\n    set((state) => {\n      const task = state.tasks.find((t) => t.id === id)\n      if (task) {\n        task.completed = !task.completed\n        task.completedAt = task.completed ? new Date() : undefined\n      }\n    })\n  },\n\n  removeTask: (id) => {\n    set((state) => {\n      const index = state.tasks.findIndex((t) => t.id === id)\n      if (index !== -1) {\n        state.tasks.splice(index, 1)\n        // Reorder remaining tasks\n        state.tasks.forEach((task, idx) => {\n          task.order = idx\n        })\n      }\n    })\n  },\n\n  updateTask: (id, updates) => {\n    set((state) => {\n      const task = state.tasks.find((t) => t.id === id)\n      if (task) {\n        Object.assign(task, updates)\n      }\n    })\n  },\n\n  clearCompleted: () => {\n    set((state) => {\n      state.tasks = state.tasks.filter((t) => !t.completed)\n      // Reorder remaining tasks\n      state.tasks.forEach((task, idx) => {\n        task.order = idx\n      })\n    })\n  },\n\n  reorderTasks: (taskIds) => {\n    set((state) => {\n      const taskMap = new Map(state.tasks.map((t) => [t.id, t]))\n      state.tasks = taskIds.map((id) => taskMap.get(id)!).filter(Boolean)\n      state.tasks.forEach((task, idx) => {\n        task.order = idx\n      })\n    })\n  },\n})\n","import { StateCreator } from 'zustand'\nimport { LumaStore, CapacitySlice, CapacityLevel } from '../types'\n\n/**\n * ADHD-friendly capacity configuration\n * Maps capacity levels to maximum task counts\n */\nconst CAPACITY_CONFIG = {\n  light: 3,\n  medium: 5,\n  full: 7,\n} as const\n\nconst initialState = {\n  currentCapacity: 'medium' as CapacityLevel,\n  maxTasks: CAPACITY_CONFIG.medium,\n}\n\n/**\n * Capacity Slice\n *\n * Manages the user's selected energy capacity for the day.\n * This prevents overcommitment - core ADHD-friendly feature.\n * This state is persisted - remembers today's capacity choice.\n */\nexport const createCapacitySlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  CapacitySlice\n> = (set) => ({\n  ...initialState,\n\n  setCapacity: (level) => {\n    set((state) => {\n      state.currentCapacity = level\n      state.maxTasks = CAPACITY_CONFIG[level]\n    })\n  },\n\n  getMaxTasksForCapacity: (level) => {\n    return CAPACITY_CONFIG[level]\n  },\n})\n","import { StateCreator } from 'zustand'\nimport { LumaStore, FocusSlice } from '../types'\n\nconst initialState = {\n  currentTaskId: null,\n  elapsedTime: 0,\n  isActive: false,\n}\n\n/**\n * Focus Slice\n *\n * Manages focus mode session state.\n * Tracks current task, elapsed time, and active status.\n * This is ephemeral state - resets on app load.\n */\nexport const createFocusSlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  FocusSlice\n> = (set) => ({\n  ...initialState,\n\n  startFocus: (taskId) => {\n    set((state) => {\n      state.currentTaskId = taskId\n      state.elapsedTime = 0\n      state.isActive = true\n    })\n  },\n\n  endFocus: () => {\n    set((state) => {\n      state.currentTaskId = null\n      state.elapsedTime = 0\n      state.isActive = false\n    })\n  },\n\n  updateElapsedTime: (seconds) => {\n    set((state) => {\n      state.elapsedTime = seconds\n    })\n  },\n})\n","import { StateCreator } from 'zustand'\nimport { LumaStore, UISlice } from '../types'\n\nconst initialState = {\n  currentView: 'brain-dump' as const,\n  modalOpen: null,\n}\n\n/**\n * UI Slice\n *\n * Manages UI state (view navigation, modals).\n * This is ephemeral state - always resets to brain-dump on load.\n */\nexport const createUISlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  UISlice\n> = (set) => ({\n  ...initialState,\n\n  setCurrentView: (view) => {\n    set((state) => {\n      state.currentView = view\n    })\n  },\n\n  openModal: (modalId) => {\n    set((state) => {\n      state.modalOpen = modalId\n    })\n  },\n\n  closeModal: () => {\n    set((state) => {\n      state.modalOpen = null\n    })\n  },\n})\n","import { StateCreator } from 'zustand'\nimport { LumaStore, SettingsSlice, LumaUserSettings, AIProvider } from '../types'\n\n/**\n * Helper function to get default AI provider based on user status\n * TODO: Implement premium user check\n */\nconst getDefaultAIProvider = (): AIProvider => {\n  // Placeholder: always return 'cloudflare' for now\n  // In future: return 'anthropic' for premium users\n  return 'cloudflare'\n}\n\n/**\n * Default ADHD-friendly settings\n */\nconst DEFAULT_SETTINGS: LumaUserSettings = {\n  defaultCapacity: 'medium',\n  theme: 'system',\n  reducedMotion: false,\n  highContrast: false,\n  fontSize: 'medium',\n  hapticFeedback: true,\n  voiceInput: false,\n  gentleNudges: true,\n  dailyReflection: false,\n  hasCompletedOnboarding: false,\n  aiProvider: getDefaultAIProvider(),\n}\n\nconst initialState = {\n  settings: DEFAULT_SETTINGS,\n}\n\n/**\n * Settings Slice\n *\n * Manages user preferences and accessibility settings.\n * All settings are persisted - remembers user choices.\n */\nexport const createSettingsSlice: StateCreator<\n  LumaStore,\n  [['zustand/immer', never]],\n  [],\n  SettingsSlice\n> = (set) => ({\n  ...initialState,\n\n  updateSettings: (updates) => {\n    set((state) => {\n      state.settings = { ...state.settings, ...updates }\n    })\n  },\n\n  resetSettings: () => {\n    set((state) => {\n      state.settings = DEFAULT_SETTINGS\n    })\n  },\n})\n"],"mappings":"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","names":["create","immer","isBrowser","storage","key","error","value","persist","config","options","set","get","api","name","version","partialize","onRehydrateStorage","loadState","persistedStateString","storage","persistedData","error","saveState","state","serialized","initialState","createBrainDumpSlice","set","text","state","isProcessing","initialState","createTasksSlice","set","task","state","newTask","tasks","startOrder","newTasks","index","id","t","idx","updates","taskIds","taskMap","CAPACITY_CONFIG","initialState","createCapacitySlice","set","level","state","initialState","createFocusSlice","set","taskId","state","seconds","initialState","createUISlice","set","view","state","modalId","getDefaultAIProvider","DEFAULT_SETTINGS","initialState","createSettingsSlice","set","updates","state","useLumaStore","create","immer","persist","args","createBrainDumpSlice","createTasksSlice","createCapacitySlice","createFocusSlice","createUISlice","createSettingsSlice","state","selectTasks","selectCurrentView","selectCapacity","selectSettings","selectBrainDumpText","selectIsProcessing","selectFocusState","selectModalOpen"]}